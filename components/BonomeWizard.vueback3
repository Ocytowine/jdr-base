<template>
  <div class="p-4 max-w-4xl mx-auto">
    <h2 class="text-2xl font-semibold mb-4">Création — Bonome Wizard (Preview)</h2>

    <!-- Selection / BaseCharacter -->
    <section class="mb-6 p-4 border rounded bg-white/80">
      <h3 class="font-medium mb-2">Sélection</h3>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
        <label class="flex flex-col">
          Classe
          <input v-model="selection.class" class="border p-1 rounded" placeholder="mage" />
        </label>
        <label class="flex flex-col">
          Race
          <input v-model="selection.race" class="border p-1 rounded" placeholder="elfe" />
        </label>
        <label class="flex flex-col">
          Niveau
          <input v-model.number="selection.niveau" type="number" min="1" class="border p-1 rounded" />
        </label>
      </div>

      <h3 class="font-medium mt-3 mb-2">Stats de base (avant race)</h3>
      <div class="grid grid-cols-3 sm:grid-cols-6 gap-2">
        <label class="flex flex-col">
          STR
          <input v-model.number="baseCharacter.base_stats_before_race.strength" type="number" class="border p-1 rounded" />
        </label>
        <label class="flex flex-col">
          DEX
          <input v-model.number="baseCharacter.base_stats_before_race.dexterity" type="number" class="border p-1 rounded" />
        </label>
        <label class="flex flex-col">
          CON
          <input v-model.number="baseCharacter.base_stats_before_race.constitution" type="number" class="border p-1 rounded" />
        </label>
        <label class="flex flex-col">
          INT
          <input v-model.number="baseCharacter.base_stats_before_race.intelligence" type="number" class="border p-1 rounded" />
        </label>
        <label class="flex flex-col">
          WIS
          <input v-model.number="baseCharacter.base_stats_before_race.wisdom" type="number" class="border p-1 rounded" />
        </label>
        <label class="flex flex-col">
          CHA
          <input v-model.number="baseCharacter.base_stats_before_race.charisma" type="number" class="border p-1 rounded" />
        </label>
      </div>

      <div class="flex gap-2 mt-4">
        <button @click="getPreview" :disabled="loading" class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-60">
          {{ loading ? 'Chargement...' : 'Obtenir la preview' }}
        </button>
        <button @click="resetPreview" class="px-3 py-1 bg-gray-200 rounded">Réinitialiser preview</button>
        <button @click="fillSample" class="px-3 py-1 bg-blue-200 rounded">Remplir ex. mage/elfe niv1</button>
      </div>
    </section>

    <!-- Preview summary -->
    <section v-if="preview" class="mb-6 p-4 border rounded bg-white/80">
      <h3 class="font-medium mb-2">Preview serveur — résumé</h3>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <h4 class="font-semibold">Stats</h4>
          <table class="text-sm">
            <thead>
              <tr>
                <th class="pr-4 text-left">Stat</th>
                <th class="pr-4 text-left">Base</th>
                <th class="pr-4 text-left">Finale</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="stat in statKeys" :key="stat">
                <td class="pr-4">{{ stat.toUpperCase() }}</td>
                <td class="pr-4">{{ baseCharStat(stat) }}</td>
                <td class="pr-4">{{ finalCharStat(stat) }}</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div>
          <h4 class="font-semibold">Sorts / Spellcasting</h4>
          <div v-if="preview.previewCharacter.spellcasting">
            <div class="text-sm mb-1">Ability: {{ preview.previewCharacter.spellcasting.ability || '-' }}</div>
            <div v-if="preview.previewCharacter.spellcasting.meta?.spell_save_dc" class="text-sm mb-1">Spell Save DC: {{ preview.previewCharacter.spellcasting.meta.spell_save_dc }}</div>
            <div v-if="preview.previewCharacter.spellcasting.meta?.spell_attack_mod" class="text-sm mb-1">Spell Attack Mod: {{ preview.previewCharacter.spellcasting.meta.spell_attack_mod }}</div>

            <div class="mt-2">
              <div class="font-medium">Slots</div>
              <div v-if="Object.keys(preview.previewCharacter.spellcasting.slots || {}).length === 0" class="text-sm">Aucun slot renseigné</div>
              <ul class="text-sm list-disc pl-5">
                <li v-for="(val, lvl) in preview.previewCharacter.spellcasting.slots" :key="lvl">Niveau {{ lvl }} : {{ val }}</li>
              </ul>
            </div>

            <div class="mt-2">
              <div class="font-medium">Sorts connus</div>
              <div v-if="(preview.previewCharacter.spellcasting.known || []).length === 0" class="text-sm">Aucun</div>
              <ul class="text-sm list-disc pl-5">
                <li v-for="s in preview.previewCharacter.spellcasting.known || []" :key="s">{{ s }}</li>
              </ul>
            </div>
          </div>
          <div v-else class="text-sm">Pas de composant spellcasting</div>
        </div>

        <div>
          <h4 class="font-semibold">Infos</h4>
          <div class="text-sm"><strong>Features appliquées :</strong></div>
          <div class="text-sm mb-2">{{ preview.appliedFeatures.join(', ') || '—' }}</div>

          <div class="text-sm"><strong>Équipement :</strong></div>
          <ul class="text-sm list-disc pl-5">
            <li v-for="(it, idx) in preview.previewCharacter.equipment || []" :key="idx">{{ formatEquipment(it) }}</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Senses / other -->
    <section v-if="preview" class="mb-6 p-4 border rounded bg-white/80">
      <h3 class="font-medium mb-2">Senses & divers</h3>
      <div v-if="(preview.previewCharacter.senses || []).length">
        <ul class="list-disc pl-5">
          <li v-for="(s, i) in preview.previewCharacter.senses" :key="i">{{ s.type }} — {{ s.range || '-' }} {{ s.units || '' }}</li>
        </ul>
      </div>
      <div v-else class="text-sm">Aucun sense renseigné</div>

      <h4 class="font-medium mt-3">Unhandled effects (pour debug)</h4>
      <pre class="text-xs bg-gray-50 p-2 rounded overflow-auto max-h-36">{{ preview.previewCharacter.unhandled_effects || '[]' }}</pre>
    </section>

    <!-- Pending choices -->
    <section v-if="preview && preview.pendingChoices?.length" class="mb-6 p-4 border rounded bg-yellow-50">
      <h3 class="font-medium mb-2">Choix à résoudre</h3>
      <div v-for="(c, idx) in preview.pendingChoices" :key="c.ui_id" class="mb-3 p-2 border rounded bg-white">
        <div class="flex items-center justify-between">
          <div>
            <div class="font-semibold">Feature : {{ c.featureId }}</div>
            <div class="text-sm text-gray-600">Note: {{ c.note || '-' }}</div>
            <div class="text-sm text-gray-600">From: {{ previewFromLabel(c.from) }}</div>
          </div>
          <div class="text-sm text-gray-600">ui_id: {{ c.ui_id }}</div>
        </div>

        <!-- chooser UI: if from is array of strings -> select; if array of objects -> select with name/id; otherwise free text -->
        <div class="mt-2 grid grid-cols-1 md:grid-cols-3 gap-2">
          <div v-if="isArrayOfStrings(c.from)">
            <select v-model="choiceInputs[c.ui_id]" class="border p-1 rounded">
              <option disabled value="">-- Choisir --</option>
              <option v-for="opt in c.from" :key="opt" :value="opt">{{ opt }}</option>
            </select>
          </div>

          <div v-else-if="isArrayOfObjects(c.from)">
            <select v-model="choiceInputs[c.ui_id]" class="border p-1 rounded">
              <option disabled value="">-- Choisir --</option>
              <option v-for="opt in c.from" :key="opt.id || opt.value || opt.name" :value="opt.id || opt.value || opt.name">{{ opt.name || opt.id || opt.value }}</option>
            </select>
          </div>

          <div v-else>
            <input v-model="choiceInputs[c.ui_id]" placeholder="Entrer id ou valeur" class="border p-1 rounded" />
          </div>

          <div class="flex gap-2">
            <button @click="applyChoice(c.ui_id)" :disabled="resolving[c.ui_id]" class="px-3 py-1 bg-blue-600 text-white rounded">
              {{ resolving[c.ui_id] ? 'Applying...' : 'Appliquer le choix' }}
            </button>
            <button @click="clearChoiceInput(c.ui_id)" class="px-3 py-1 bg-gray-200 rounded">Effacer</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Errors -->
    <section v-if="preview && preview.errors?.length" class="mb-6 p-4 border rounded bg-red-50">
      <h3 class="font-medium mb-2">Erreurs & diagnostics</h3>
      <ul class="list-disc pl-5 text-sm">
        <li v-for="(e, i) in preview.errors" :key="i">
          <div><strong>{{ e.type }}</strong> — source: {{ e.source || '-' }} — {{ e.message }}</div>
          <pre class="text-xs bg-white p-2 rounded mt-1 overflow-auto max-h-48">{{ e.effect ? JSON.stringify(e.effect, null, 2) : '' }}</pre>
        </li>
      </ul>
    </section>

    <!-- Raw debug -->
    <section v-if="preview" class="mb-6 p-4 border rounded bg-gray-50">
      <h3 class="font-medium mb-2">Raw response (debug)</h3>
      <pre class="text-xs max-h-64 overflow-auto">{{ preview }}</pre>
    </section>

    <div v-if="lastError" class="text-red-600 mt-4">{{ lastError }}</div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, watch } from 'vue';

/**
 * BonomeWizard.vue
 * Client-side component to interact with:
 *  - POST /api/creation/preview
 *  - POST /api/creation/resolve-choice
 *
 * Keep simple: selection & baseCharacter local (can be replaced by your store).
 */

// selection and baseCharacter local state
const selection = reactive({
  class: 'mage',
  race: 'elfe',
  subclass: null as string | null,
  background: null as string | null,
  manual_features: [] as string[],
  chosenOptions: {} as Record<string, any>,
  niveau: 1
});

const baseCharacter = reactive({
  base_stats_before_race: {
    strength: 8,
    dexterity: 14,
    constitution: 12,
    intelligence: 16,
    wisdom: 10,
    charisma: 11
  },
  niveau: 1,
  features: [] as string[],
  equipment: [] as any[],
  spellcasting: {}
});

// preview result
const preview = ref<any | null>(null);
const loading = ref(false);
const lastError = ref<string | null>(null);

// pending choice inputs (by ui_id)
const choiceInputs = reactive<Record<string, any>>({});
const resolving = reactive<Record<string, boolean>>({});

// util keys for stats
const statKeys = ['strength','dexterity','constitution','intelligence','wisdom','charisma'] as const;

function baseCharStat(stat: string) {
  return baseCharacter.base_stats_before_race?.[stat] ?? '-';
}
function finalCharStat(stat: string) {
  return preview.value?.previewCharacter?.final_stats?.[stat] ?? baseCharStat(stat);
}

function formatEquipment(it: any) {
  if (!it) return '-';
  if (typeof it === 'string') return it;
  if (it.id) return `${it.id}${it.qty ? ' x' + it.qty : ''}`;
  return JSON.stringify(it);
}

function isArrayOfStrings(x: any) {
  return Array.isArray(x) && x.every((v:any) => typeof v === 'string');
}
function isArrayOfObjects(x: any) {
  return Array.isArray(x) && x.every((v:any) => typeof v === 'object' && v !== null);
}
function previewFromLabel(from: any) {
  if (!from) return '-';
  if (isArrayOfStrings(from)) return `options (${from.length})`;
  if (isArrayOfObjects(from)) return `objects (${from.length})`;
  return JSON.stringify(from);
}

/* -------------------------
   API calls
   ------------------------- */
async function getPreview() {
  loading.value = true;
  lastError.value = null;
  preview.value = null;
  try {
    const body = {
      selection: { ...selection },
      baseCharacter: { ...baseCharacter }
    };
    const res = await fetch('/api/creation/preview', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    const data = await res.json();
    if (!data) throw new Error('Aucune réponse');
    preview.value = data;
    // prefill choiceInputs with empty string for pending choices
    if (data?.pendingChoices?.length) {
      for (const c of data.pendingChoices) {
        if (choiceInputs[c.ui_id] === undefined) choiceInputs[c.ui_id] = '';
      }
    }
  } catch (err: any) {
    console.error('getPreview error', err);
    lastError.value = String(err.message || err);
  } finally {
    loading.value = false;
  }
}

async function applyChoice(ui_id: string) {
  // simple validation
  const val = choiceInputs[ui_id];
  if (val === undefined || val === null || val === '') {
    alert('Choix vide — entrez une valeur avant d\'appliquer.');
    return;
  }
  resolving[ui_id] = true;
  lastError.value = null;
  try {
    const body = {
      ui_id,
      value: val,
      selection: { ...selection, chosenOptions: { ...(selection.chosenOptions || {}), [ui_id]: val } },
      baseCharacter: { ...baseCharacter }
    };
    const res = await fetch('/api/creation/resolve-choice', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    const data = await res.json();
    if (!data) throw new Error('Aucune réponse du serveur');
    preview.value = data;
    // update selection.chosenOptions locally to persist the choice
    selection.chosenOptions = selection.chosenOptions || {};
    selection.chosenOptions[ui_id] = val;
  } catch (err: any) {
    console.error('applyChoice error', err);
    lastError.value = String(err.message || err);
  } finally {
    resolving[ui_id] = false;
  }
}

function clearChoiceInput(ui_id: string) {
  choiceInputs[ui_id] = '';
}

/* helpers for quick testing */
function resetPreview() {
  preview.value = null;
  lastError.value = null;
  // preserve selection/baseCharacter but clear chosenOptions
  selection.chosenOptions = {};
  for (const k in choiceInputs) delete choiceInputs[k];
}

function fillSample() {
  selection.class = 'mage';
  selection.race = 'elfe';
  selection.niveau = 1;
  baseCharacter.base_stats_before_race = { strength: 8, dexterity: 14, constitution: 12, intelligence: 16, wisdom: 10, charisma: 11 };
}

</script>

<style scoped>
/* minimal styling - your project probably already has Tailwind */
pre { white-space: pre-wrap; word-break: break-word; }
</style>
